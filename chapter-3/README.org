* About
  /Data/ and /Data Structures/ are like a coin with two faces. Some data could be implemented in many forms, or indeed structures. Each one has major advantages and disadvantages, in terms of /space usage/ and in terms of /operations efficiency/. Thus, the choice of a particular data structure among others has a key roll in the efficiency of an /algorithm/ in order to save /time/ and/or /space/.

* Things learned in this chapter
  + Data Structure != passive object :: Applied operations matters too.
  + Array indexes can be very handy :: =[i%2]= or =[i*j]= or even =[foo[i]]=
  + 3d arrays are handy beside 3d objects :: =[year][student][grade]=
  + basic linked list operations are :: =insert()= or =delete()= after a node
  + linked lists could be implemented using arrays :: i.e. parallel arrays
  + basic pushdown stacks operations :: =push()= to head, =pop()= from head
  + stacks require fewer space for much operations :: =pop()='s frees the space for =push()='s

* Nice facts
** about Arrays
   + if the index is /known/, all arrays accesses are done in /constant time/
   + beside the fact that arrays could be dynamical allocated, they still have the fundamental proprietary such that /their size must be known/ before actually using the array
   + arrays have a direct impact on memory systems, as that we can /think of memory a big array/ while the index is the actual /memory address/
     - some computer /language processors/ *translate* program instructions that involve array usage into rather more effecient instructions that /access the computer memory directly/
   + 1d arrays are mathematical /vectors/ same as 2d arrays are mathematical /matrices/

** about Linked Lists
   suppose we have the following linked list named /list/ that contains { =head= \to =car= \to =tar= \to =foo= \to =z= } while =head= and =z= are the /head/ and /tail/ of the list respectively

   + /finding/ elements that are relative to k^{th} position is not suitable for linked lists as that we have to cross the list $k$ times to reache the target node
   + /deleting/ elements do not remove them from the memory, but they've become +comfortably numb+ not accessible if we walk the list from the /head/.
     - matter of fact, the removed element still points to whatever it has pointed to before.
   + /parallel arrays/ has advanteges over using pointers. for instance, data is always in a =key= arrays while links are in a =next= array. this means that data is separated from the links, so that data could be shared or added when needed.
** about Pushdown Stacks, a.k.a. LIFO -- Last In First Out  
   + sometimes, there's no need to keep tracking of all the links. which leads to few operations to handle..
   + pushdown stacks are the most important restricted-access data structure.
   + /push/ element to the head of the stack
   + /pop/ from the head of the stack
   + some calculators and programming languages base their calculations on stack operations e.g. [[example 1]]
   + if operations are somehow related, then a small stack could be used to perform large set of operations, +if this is the case after all+ 

*** example 1
   #+BEGIN_SRC C
   /* this is to compute the following expressing:
    *	5 x (((9 + 8) x (4 x 6)) + 7) 
    */
   /* ----------- prototypes ----------- */
   void push(int value);
   int pop();
    
   push(5);
   push(9);
   push(8);
   push(pop() + pop());		/* n = 8 + 9 */

   push(4);
   push(6);
   push(pop() * pop());		/* m = 6 x 4 */
   push(pop() * pop());		/* p = m x n */
   
   push(7);
   push(pop() + pop());		/* q = p + 7 */
   push(pop() * pop());		/* q x 5 */
   
   int result = pop();
   #+END_SRC
** about Queues, a.k.a. FIFO -- First In First Out 
   + same as stack, the only difference is that when =remove()= an element, it's from the back. and when =insert()= an element, it's in the front
